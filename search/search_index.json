{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Async Python Rest Client Schema Registry Async Python Rest Client to interact against schema-registry confluent server to manage Avro Schemas resources. Requirements python 3.6+, fastavro, requests-async, aiofile Installation pip install async-python-schema-registry-client When use this library? Usually, we have a situacion like this: So, our producers/consumers have to serialize/deserialize messages every time that they send/receive from Kafka topics. In this picture, we can imagine a Faust application receiving messages (encoded with an Avro schema) and we want to deserialize them, so we can ask the schema server to do that for us. In this scenario, the MessageSerializer is perfect. Also, could be a use case that we would like to have an Application only to administrate Avro Schemas (register, update compatibilities, delete old schemas, etc.), so the SchemaRegistryClient is perfect. Development The tests are run against the Schema Server using docker compose , so you will need Docker and Docker Compose installed. ./scripts/test.sh Lint code: ./scripts/lint","title":"Introduction"},{"location":"#async-python-rest-client-schema-registry","text":"Async Python Rest Client to interact against schema-registry confluent server to manage Avro Schemas resources.","title":"Async Python Rest Client Schema Registry"},{"location":"#requirements","text":"python 3.6+, fastavro, requests-async, aiofile","title":"Requirements"},{"location":"#installation","text":"pip install async-python-schema-registry-client","title":"Installation"},{"location":"#when-use-this-library","text":"Usually, we have a situacion like this: So, our producers/consumers have to serialize/deserialize messages every time that they send/receive from Kafka topics. In this picture, we can imagine a Faust application receiving messages (encoded with an Avro schema) and we want to deserialize them, so we can ask the schema server to do that for us. In this scenario, the MessageSerializer is perfect. Also, could be a use case that we would like to have an Application only to administrate Avro Schemas (register, update compatibilities, delete old schemas, etc.), so the SchemaRegistryClient is perfect.","title":"When use this library?"},{"location":"#development","text":"The tests are run against the Schema Server using docker compose , so you will need Docker and Docker Compose installed. ./scripts/test.sh Lint code: ./scripts/lint","title":"Development"},{"location":"client/","text":"Client The Schema Registry Client consumes the API exposed by the schema-registry to operate resources that are avro schemas. You probably won't use this but is good to know that exists. The MessageSerialzer is whom interact with the SchemaRegistryClient SchemaRegistryClient: SchemaRegistryClient A client that talks to a Schema Registry over HTTP def __init__ ( self , url , ca_location = None , cert_location = None , key_location = None , extra_headers = None ) Args : url ( str | dict ) url : Url to schema registry or dictionary containing client configuration . ca_location ( str ): File or directory path to CA certificate ( s ) for verifying the Schema Registry key . cert_location ( str ): Path to public key used for authentication . key_location ( str ): Path to private key used for authentication . extra_headers ( dict ): Extra headers to add on every requests . Methods: Get Schema Get Schema for a given version. If version is None , try to resolve the latest schema async def get_schema ( subject : str , version = \"latest\" , headers : dict = None ) -> utils . SchemaVersion : \"\"\" Args: subject (str): subject name version (int, optional): version id. If is None, the latest schema is returned headers (dict): Extra headers to add on the requests Returns: utils.SchemaVersion (nametupled): (subject, schema_id, schema, version) None: If server returns a not success response: 404: Schema not found 422: Unprocessable entity ~ (200 - 299): Not success \"\"\" Get schema by id : async def get_by_id ( schema_id : int , headers : dict = None ) -> client . schema . AvroSchema : \"\"\" Args: schema_id (int): Schema Id headers (dict): Extra headers to add on the requests Returns: client.schema.AvroSchema: Avro Record schema \"\"\" Register a Schema: async def register ( subject : str , avro_schema : client . schema . AvroSchema , headers : dict = None ) -> int : \"\"\" Args: subject (str): subject name avro_schema (avro.schema.RecordSchema): Avro schema to be registered headers (dict): Extra headers to add on the requests Returns: int: schema_id \"\"\" Get Subjects async def get_subjects ( self , headers : dict = None ) -> list : \"\"\" GET /subjects/(string: subject) Get list of all registered subjects in your Schema Registry. Args: subject (str): subject name headers (dict): Extra headers to add on the requests Returns: list [str]: list of registered subjects. \"\"\" Delete Schema async def delete_subject ( subject : str , headers : dict = None ) -> list : \"\"\" Args: subject (str): subject name headers (dict): Extra headers to add on the requests Returns: list (int): versions of the schema deleted under this subject \"\"\" Check if a schema has already been registered under the specified subject async def check_version ( subject : str , avro_schema : client . schema . AvroSchema , headers : dict = None ) -> dict : \"\"\" Args: subject (str): subject name avro_schema (avro.schema.RecordSchema): Avro schema headers (dict): Extra headers to add on the requests Returns: dict: subject (string) -- Name of the subject that this schema is registered under id (int) -- Globally unique identifier of the schema version (int) -- Version of the returned schema schema (dict) -- The Avro schema None: If schema not found. \"\"\" Get schema version under a specific subject async def get_versions ( self , subject : str , headers : dict = None ) -> list : \"\"\" GET subjects/{subject}/versions Get a list of versions registered under the specified subject. Args: subject (str): subject name headers (dict): Extra headers to add on the requests Returns: list (str): version of the schema registered under this subject \"\"\" Deletes a specific version of the schema registered under a subject async def delete_version ( self , subject : str , version = \"latest\" , headers : dict = None ): \"\"\" DELETE /subjects/(string: subject)/versions/(versionId: version) Deletes a specific version of the schema registered under this subject. This only deletes the version and the schema ID remains intact making it still possible to decode data using the schema ID. This API is recommended to be used only in development environments or under extreme circumstances where-in, its required to delete a previously registered schema for compatibility purposes or re-register previously registered schema. Args: subject (str): subject name version (str): Version of the schema to be deleted. Valid values for versionId are between [1,2^31-1] or the string \"latest\". \"latest\" deletes the last registered schema under the specified subject. headers (dict): Extra headers to add on the requests Returns: int: version of the schema deleted None: If the subject or version does not exist. \"\"\" Test Compatibility: async def test_compatibility ( subject : str , avro_schema : client . schema . AvroSchema , version = \"latest\" , headers : dict = None ): \"\"\" By default the latest version is checked against. Args: subject (str): subject name avro_schema (avro.schema.RecordSchema): Avro schema parsed headers (dict): Extra headers to add on the requests Returns: bool: True if schema given compatible, False otherwise \"\"\" Get Compatibility: async def get_compatibility ( subject : str , headers : dict = None ) -> str : \"\"\" Get the current compatibility level for a subject. Result will be one of: Args: subject (str): subject name headers (dict): Extra headers to add on the requests Returns: str: one of BACKWARD, BACKWARD_TRANSITIVE, FORWARD, FORWARD_TRANSITIVE, FULL, FULL_TRANSITIVE, NONE Raises: ClientError: if the request was unsuccessful or an invalid compatibility level was returned \"\"\" Update Compatibility: async def update_compatibility ( level : str , subject : str , headers : dict = None ) -> bool : \"\"\" Update the compatibility level for a subject. If subject is None, the compatibility level is global. Args: level (str): one of BACKWARD, BACKWARD_TRANSITIVE, FORWARD, FORWARD_TRANSITIVE, FULL, FULL_TRANSITIVE, NONE headers (dict): Extra headers to add on the requests Returns: bool: True if compatibility was updated Raises: ClientError: if the request was unsuccessful or an invalid \"\"\"","title":"SchemaRegistryClient Api"},{"location":"client/#client","text":"The Schema Registry Client consumes the API exposed by the schema-registry to operate resources that are avro schemas. You probably won't use this but is good to know that exists. The MessageSerialzer is whom interact with the SchemaRegistryClient","title":"Client"},{"location":"client/#schemaregistryclient","text":"SchemaRegistryClient A client that talks to a Schema Registry over HTTP def __init__ ( self , url , ca_location = None , cert_location = None , key_location = None , extra_headers = None ) Args : url ( str | dict ) url : Url to schema registry or dictionary containing client configuration . ca_location ( str ): File or directory path to CA certificate ( s ) for verifying the Schema Registry key . cert_location ( str ): Path to public key used for authentication . key_location ( str ): Path to private key used for authentication . extra_headers ( dict ): Extra headers to add on every requests .","title":"SchemaRegistryClient:"},{"location":"client/#methods","text":"","title":"Methods:"},{"location":"client/#get-schema","text":"Get Schema for a given version. If version is None , try to resolve the latest schema async def get_schema ( subject : str , version = \"latest\" , headers : dict = None ) -> utils . SchemaVersion : \"\"\" Args: subject (str): subject name version (int, optional): version id. If is None, the latest schema is returned headers (dict): Extra headers to add on the requests Returns: utils.SchemaVersion (nametupled): (subject, schema_id, schema, version) None: If server returns a not success response: 404: Schema not found 422: Unprocessable entity ~ (200 - 299): Not success \"\"\"","title":"Get Schema"},{"location":"client/#get-schema-by-id","text":"async def get_by_id ( schema_id : int , headers : dict = None ) -> client . schema . AvroSchema : \"\"\" Args: schema_id (int): Schema Id headers (dict): Extra headers to add on the requests Returns: client.schema.AvroSchema: Avro Record schema \"\"\"","title":"Get schema by id:"},{"location":"client/#register-a-schema","text":"async def register ( subject : str , avro_schema : client . schema . AvroSchema , headers : dict = None ) -> int : \"\"\" Args: subject (str): subject name avro_schema (avro.schema.RecordSchema): Avro schema to be registered headers (dict): Extra headers to add on the requests Returns: int: schema_id \"\"\"","title":"Register a Schema:"},{"location":"client/#get-subjects","text":"async def get_subjects ( self , headers : dict = None ) -> list : \"\"\" GET /subjects/(string: subject) Get list of all registered subjects in your Schema Registry. Args: subject (str): subject name headers (dict): Extra headers to add on the requests Returns: list [str]: list of registered subjects. \"\"\"","title":"Get Subjects"},{"location":"client/#delete-schema","text":"async def delete_subject ( subject : str , headers : dict = None ) -> list : \"\"\" Args: subject (str): subject name headers (dict): Extra headers to add on the requests Returns: list (int): versions of the schema deleted under this subject \"\"\"","title":"Delete Schema"},{"location":"client/#check-if-a-schema-has-already-been-registered-under-the-specified-subject","text":"async def check_version ( subject : str , avro_schema : client . schema . AvroSchema , headers : dict = None ) -> dict : \"\"\" Args: subject (str): subject name avro_schema (avro.schema.RecordSchema): Avro schema headers (dict): Extra headers to add on the requests Returns: dict: subject (string) -- Name of the subject that this schema is registered under id (int) -- Globally unique identifier of the schema version (int) -- Version of the returned schema schema (dict) -- The Avro schema None: If schema not found. \"\"\"","title":"Check if a schema has already been registered under the specified subject"},{"location":"client/#get-schema-version-under-a-specific-subject","text":"async def get_versions ( self , subject : str , headers : dict = None ) -> list : \"\"\" GET subjects/{subject}/versions Get a list of versions registered under the specified subject. Args: subject (str): subject name headers (dict): Extra headers to add on the requests Returns: list (str): version of the schema registered under this subject \"\"\"","title":"Get schema version under a specific subject"},{"location":"client/#deletes-a-specific-version-of-the-schema-registered-under-a-subject","text":"async def delete_version ( self , subject : str , version = \"latest\" , headers : dict = None ): \"\"\" DELETE /subjects/(string: subject)/versions/(versionId: version) Deletes a specific version of the schema registered under this subject. This only deletes the version and the schema ID remains intact making it still possible to decode data using the schema ID. This API is recommended to be used only in development environments or under extreme circumstances where-in, its required to delete a previously registered schema for compatibility purposes or re-register previously registered schema. Args: subject (str): subject name version (str): Version of the schema to be deleted. Valid values for versionId are between [1,2^31-1] or the string \"latest\". \"latest\" deletes the last registered schema under the specified subject. headers (dict): Extra headers to add on the requests Returns: int: version of the schema deleted None: If the subject or version does not exist. \"\"\"","title":"Deletes a specific version of the schema registered under a subject"},{"location":"client/#test-compatibility","text":"async def test_compatibility ( subject : str , avro_schema : client . schema . AvroSchema , version = \"latest\" , headers : dict = None ): \"\"\" By default the latest version is checked against. Args: subject (str): subject name avro_schema (avro.schema.RecordSchema): Avro schema parsed headers (dict): Extra headers to add on the requests Returns: bool: True if schema given compatible, False otherwise \"\"\"","title":"Test Compatibility:"},{"location":"client/#get-compatibility","text":"async def get_compatibility ( subject : str , headers : dict = None ) -> str : \"\"\" Get the current compatibility level for a subject. Result will be one of: Args: subject (str): subject name headers (dict): Extra headers to add on the requests Returns: str: one of BACKWARD, BACKWARD_TRANSITIVE, FORWARD, FORWARD_TRANSITIVE, FULL, FULL_TRANSITIVE, NONE Raises: ClientError: if the request was unsuccessful or an invalid compatibility level was returned \"\"\"","title":"Get Compatibility:"},{"location":"client/#update-compatibility","text":"async def update_compatibility ( level : str , subject : str , headers : dict = None ) -> bool : \"\"\" Update the compatibility level for a subject. If subject is None, the compatibility level is global. Args: level (str): one of BACKWARD, BACKWARD_TRANSITIVE, FORWARD, FORWARD_TRANSITIVE, FULL, FULL_TRANSITIVE, NONE headers (dict): Extra headers to add on the requests Returns: bool: True if compatibility was updated Raises: ClientError: if the request was unsuccessful or an invalid \"\"\"","title":"Update Compatibility:"},{"location":"exceptions/","text":"ClientError An instance of ClientError is returned when an error occurs. class ClientError ( Exception ): \"\"\" Error thrown by Schema Registry clients \"\"\" def __init__ ( self , message , http_code = None , server_traceback = None ): self . message = message self . server_traceback = server_traceback self . http_code = http_code super ( ClientError , self ) . __init__ ( self . __str__ ()) def __repr__ ( self ): return f \"ClientError(error={self.message})\" def __str__ ( self ): return self . message For example: try : # Try to get the compatibility level of a subject that does not exist # The Schema Registry Server returns 404 compatibility = async client . get_compatibility ( \"subject-does-not-exists\" ) except Exception as error : # Print 404 print ( error . http_code )","title":"Exceptions"},{"location":"exceptions/#clienterror","text":"An instance of ClientError is returned when an error occurs. class ClientError ( Exception ): \"\"\" Error thrown by Schema Registry clients \"\"\" def __init__ ( self , message , http_code = None , server_traceback = None ): self . message = message self . server_traceback = server_traceback self . http_code = http_code super ( ClientError , self ) . __init__ ( self . __str__ ()) def __repr__ ( self ): return f \"ClientError(error={self.message})\" def __str__ ( self ): return self . message For example: try : # Try to get the compatibility level of a subject that does not exist # The Schema Registry Server returns 404 compatibility = async client . get_compatibility ( \"subject-does-not-exists\" ) except Exception as error : # Print 404 print ( error . http_code )","title":"ClientError"},{"location":"schemaregistry_server/","text":"Schema Registry Server This section provides you just an introduction about the Schema Server . Schema Registry provides a serving layer for your metadata. It provides a RESTful interface for storing and retrieving Avro schemas. It stores a versioned history of all schemas, provides multiple compatibility settings and allows evolution of schemas according to the configured compatibility settings and expanded Avro support. It provides serializers that plug into Apache Kafka\u00ae clients that handle schema storage and retrieval for Kafka messages that are sent in the Avro format. Schema Registry is a distributed storage layer for Avro Schemas which uses Kafka as its underlying storage mechanism. Some key design decisions: Assigns globally unique ID to each registered schema. Allocated IDs are guaranteed to be monotonically increasing but not necessarily consecutive. Kafka provides the durable backend, and functions as a write-ahead changelog for the state of Schema Registry and the schemas it contains. Schema Registry is designed to be distributed, with single-primary architecture, and ZooKeeper/Kafka coordinates primary election (based on the configuration). API Schemas GET /schemas/ids/{int: id} - Get the schema string identified by the input ID Subjects GET /subjects - Get a list of registered subjects. [Missing] GET /subjects/(string: subject)/versions - Get a list of versions registered under the specified subject [Missing] DELETE /subjects/(string: subject) - Deletes the specified subject and its associated compatibility level if registered. It is recommended to use this API only when a topic needs to be recycled or in development environment. GET /subjects/(string: subject)/versions/(versionId: version) - Get a specific version of the schema registered under this subject Check response GET /subjects/(string: subject)/versions/(versionId: version)/schema - Get the avro schema for the specified version of this subject. The unescaped schema only is returned. [Missing] POST /subjects/(string: subject)/versions - Register a new schema under the specified subject and receive a schema id POST /subjects/(string: subject) - Check if a schema has already been registered under the specified subject. If so, this returns the schema string along with its globally unique identifier, its version under this subject and the subject name. DELETE /subjects/(string: subject)/versions/(versionId: version) - Deletes a specific version of the schema registered under this subject. This only deletes the version and the schema ID remains intact making it still possible to decode data using the schema ID. This API is recommended to be used only in development environments or under extreme circumstances where-in, its required to delete a previously registered schema for compatibility purposes or re-register previously registered schema. [Missing] Compatibility POST /compatibility/subjects/(string: subject)/versions/(versionId: version) - Test input schema against a particular version of a subject's schema for compatibility. Note that the compatibility level applied for the check is the configured compatibility level for the subject (http:get:: /config/(string: subject)). If this subject's compatibility level was never changed, then the global compatibility level applies (http:get:: /config). These are the compatibility types: BACKWARD : (default) consumers using the new schema can read data written by producers using the latest registered schema BACKWARD_TRANSITIVE : consumers using the new schema can read data written by producers using all previously registered schemas FORWARD : consumers using the latest registered schema can read data written by producers using the new schema FORWARD_TRANSITIVE : consumers using all previously registered schemas can read data written by producers using the new schema FULL : the new schema is forward and backward compatible with the latest registered schema FULL_TRANSITIVE : the new schema is forward and backward compatible with all previously registered schemas NONE : schema compatibility checks are disabled Config GET /config - Get global compatibility level. PUT /config - Update global compatibility level. [Missing] GET /config/(string: subject) - Get compatibility level for a subject. [Missing] PUT /config/(string: subject) - Update compatibility level for the specified subject. Too know more about the API go here","title":"Schema Registry Server"},{"location":"schemaregistry_server/#schema-registry-server","text":"This section provides you just an introduction about the Schema Server . Schema Registry provides a serving layer for your metadata. It provides a RESTful interface for storing and retrieving Avro schemas. It stores a versioned history of all schemas, provides multiple compatibility settings and allows evolution of schemas according to the configured compatibility settings and expanded Avro support. It provides serializers that plug into Apache Kafka\u00ae clients that handle schema storage and retrieval for Kafka messages that are sent in the Avro format. Schema Registry is a distributed storage layer for Avro Schemas which uses Kafka as its underlying storage mechanism. Some key design decisions: Assigns globally unique ID to each registered schema. Allocated IDs are guaranteed to be monotonically increasing but not necessarily consecutive. Kafka provides the durable backend, and functions as a write-ahead changelog for the state of Schema Registry and the schemas it contains. Schema Registry is designed to be distributed, with single-primary architecture, and ZooKeeper/Kafka coordinates primary election (based on the configuration).","title":"Schema Registry Server"},{"location":"schemaregistry_server/#api","text":"","title":"API"},{"location":"schemaregistry_server/#schemas","text":"GET /schemas/ids/{int: id} - Get the schema string identified by the input ID","title":"Schemas"},{"location":"schemaregistry_server/#subjects","text":"GET /subjects - Get a list of registered subjects. [Missing] GET /subjects/(string: subject)/versions - Get a list of versions registered under the specified subject [Missing] DELETE /subjects/(string: subject) - Deletes the specified subject and its associated compatibility level if registered. It is recommended to use this API only when a topic needs to be recycled or in development environment. GET /subjects/(string: subject)/versions/(versionId: version) - Get a specific version of the schema registered under this subject Check response GET /subjects/(string: subject)/versions/(versionId: version)/schema - Get the avro schema for the specified version of this subject. The unescaped schema only is returned. [Missing] POST /subjects/(string: subject)/versions - Register a new schema under the specified subject and receive a schema id POST /subjects/(string: subject) - Check if a schema has already been registered under the specified subject. If so, this returns the schema string along with its globally unique identifier, its version under this subject and the subject name. DELETE /subjects/(string: subject)/versions/(versionId: version) - Deletes a specific version of the schema registered under this subject. This only deletes the version and the schema ID remains intact making it still possible to decode data using the schema ID. This API is recommended to be used only in development environments or under extreme circumstances where-in, its required to delete a previously registered schema for compatibility purposes or re-register previously registered schema. [Missing]","title":"Subjects"},{"location":"schemaregistry_server/#compatibility","text":"POST /compatibility/subjects/(string: subject)/versions/(versionId: version) - Test input schema against a particular version of a subject's schema for compatibility. Note that the compatibility level applied for the check is the configured compatibility level for the subject (http:get:: /config/(string: subject)). If this subject's compatibility level was never changed, then the global compatibility level applies (http:get:: /config). These are the compatibility types: BACKWARD : (default) consumers using the new schema can read data written by producers using the latest registered schema BACKWARD_TRANSITIVE : consumers using the new schema can read data written by producers using all previously registered schemas FORWARD : consumers using the latest registered schema can read data written by producers using the new schema FORWARD_TRANSITIVE : consumers using all previously registered schemas can read data written by producers using the new schema FULL : the new schema is forward and backward compatible with the latest registered schema FULL_TRANSITIVE : the new schema is forward and backward compatible with all previously registered schemas NONE : schema compatibility checks are disabled","title":"Compatibility"},{"location":"schemaregistry_server/#config","text":"GET /config - Get global compatibility level. PUT /config - Update global compatibility level. [Missing] GET /config/(string: subject) - Get compatibility level for a subject. [Missing] PUT /config/(string: subject) - Update compatibility level for the specified subject. Too know more about the API go here","title":"Config"},{"location":"serializer/","text":"Message Serializer Class that serialize and deserialize messages. It interacts with the SchemaRegistryClient to get Avro Schemas in order to process messages. In your application you will intereact with it. Usage: from schema_registry.client import SchemaRegistryClient , schema from schema_registry.serializers import MessageSerializer client = SchemaRegistryClient ( \"http://127.0.0.1:8080\" ) message_serializer = MessageSerializer ( client ) # Let's imagine that we have the foillowing schema. avro_user_schema = schema . AvroSchema ({ \"type\" : \"record\" , \"namespace\" : \"com.example\" , \"name\" : \"AvroUsers\" , \"fields\" : [ { \"name\" : \"first_name\" , \"type\" : \"string\" }, { \"name\" : \"last_name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, ], }) # We want to encode the user_record with avro_user_schema user_record = { \"first_name\" : \"my_first_name\" , \"last_name\" : \"my_last_name\" , \"age\" : 20 , } message_encoded = await message_serializer . encode_record_with_schema ( \"user\" , avro_user_schema , user_record ) # this is because the message encoded reserved 5 bytes for the schema_id assert len ( message_encoded ) > 5 assert isinstance ( message_encoded , bytes ) # now decode the message message_decoded = await message_serializer . decode_message ( message_encoded ) assert message_decoded == user_record # Now if we send a bad record bad_record = { \"first_name\" : \"my_first_name\" , \"last_name\" : \"my_last_name\" , \"age\" : \"my_age\" } await message_serializer . encode_record_with_schema ( \"user\" , avro_user_schema , bad_record ) # results in an error: # TypeError: unsupported operand type(s) for <<: 'str' and 'int' Class and Methods: MessageSerializer Args : schemaregistry_client ( schema_registry . client . SchemaRegistryClient ): Http Client Encode record with a Schema : async def encode_record_with_schema ( subject , schema , record , is_key = False ): \"\"\" Args: subject (str): Subject name schema (avro.schema.RecordSchema): Avro Schema record (dict): An object to serialize is_key (bool): If the record is a key Returns: bytes: Encoded record with schema ID as bytes \"\"\" Encode a record with a schema id : async def encode_record_with_schema_id ( schema_id , record , is_key = False ): \"\"\" Args: schema_id (int): integer ID record (dict): An object to serialize is_key (bool): If the record is a key Returns: func: decoder function \"\"\" Decode a message encoded previously: async def decode_message ( message , is_key = False ): \"\"\" Args: message (str|bytes or None): message key or value to be decoded Returns: dict: Decoded message contents. \"\"\"","title":"Message Serializer"},{"location":"serializer/#message-serializer","text":"Class that serialize and deserialize messages. It interacts with the SchemaRegistryClient to get Avro Schemas in order to process messages. In your application you will intereact with it.","title":"Message Serializer"},{"location":"serializer/#usage","text":"from schema_registry.client import SchemaRegistryClient , schema from schema_registry.serializers import MessageSerializer client = SchemaRegistryClient ( \"http://127.0.0.1:8080\" ) message_serializer = MessageSerializer ( client ) # Let's imagine that we have the foillowing schema. avro_user_schema = schema . AvroSchema ({ \"type\" : \"record\" , \"namespace\" : \"com.example\" , \"name\" : \"AvroUsers\" , \"fields\" : [ { \"name\" : \"first_name\" , \"type\" : \"string\" }, { \"name\" : \"last_name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, ], }) # We want to encode the user_record with avro_user_schema user_record = { \"first_name\" : \"my_first_name\" , \"last_name\" : \"my_last_name\" , \"age\" : 20 , } message_encoded = await message_serializer . encode_record_with_schema ( \"user\" , avro_user_schema , user_record ) # this is because the message encoded reserved 5 bytes for the schema_id assert len ( message_encoded ) > 5 assert isinstance ( message_encoded , bytes ) # now decode the message message_decoded = await message_serializer . decode_message ( message_encoded ) assert message_decoded == user_record # Now if we send a bad record bad_record = { \"first_name\" : \"my_first_name\" , \"last_name\" : \"my_last_name\" , \"age\" : \"my_age\" } await message_serializer . encode_record_with_schema ( \"user\" , avro_user_schema , bad_record ) # results in an error: # TypeError: unsupported operand type(s) for <<: 'str' and 'int'","title":"Usage:"},{"location":"serializer/#class-and-methods","text":"MessageSerializer Args : schemaregistry_client ( schema_registry . client . SchemaRegistryClient ): Http Client","title":"Class and Methods:"},{"location":"serializer/#encode-record-with-a-schema","text":"async def encode_record_with_schema ( subject , schema , record , is_key = False ): \"\"\" Args: subject (str): Subject name schema (avro.schema.RecordSchema): Avro Schema record (dict): An object to serialize is_key (bool): If the record is a key Returns: bytes: Encoded record with schema ID as bytes \"\"\"","title":"Encode record with a Schema:"},{"location":"serializer/#encode-a-record-with-a-schema-id","text":"async def encode_record_with_schema_id ( schema_id , record , is_key = False ): \"\"\" Args: schema_id (int): integer ID record (dict): An object to serialize is_key (bool): If the record is a key Returns: func: decoder function \"\"\"","title":"Encode a record with a schema id:"},{"location":"serializer/#decode-a-message-encoded-previously","text":"async def decode_message ( message , is_key = False ): \"\"\" Args: message (str|bytes or None): message key or value to be decoded Returns: dict: Decoded message contents. \"\"\"","title":"Decode a message encoded previously:"}]}